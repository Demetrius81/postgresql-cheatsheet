
## 1. Основы и архитектура

**Вопрос:** Что такое MVCC и зачем нужен `VACUUM` в PostgreSQL?
**Ответ:** MVCC (Multiversion Concurrency Control) позволяет PostgreSQL создавать “снимки” данных для каждой транзакции, чтобы чтения не блокировались записями, а записи — чтениями. При обновлении строк старые версии остаются (“мертвые кортежи”), и их нужно очищать — для этого используется `VACUUM`. Также `ANALYZE` обновляет статистику, что помогает планировщику строить оптимальные планы. 
**Пример кода:**

```sql
VACUUM ANALYZE my_table;
```

---

**Вопрос:** Объясните изоляционные уровни в PostgreSQL (Read Committed, Repeatable Read, Serializable).
**Ответ:**

* `Read Committed`: транзакция видит только уже зафиксированные изменения — “грязные чтения” невозможны.
* `Repeatable Read`: транзакция видит единую “снимок” базы на начало транзакции — предотвращает неповторяющееся чтение, но может быть “фантомное чтение”.
* `Serializable`: самая строгая, имитирует последовательное выполнение транзакций, предотвращая все аномалии, но может возникать блокировка.
  **Пример (установка уровня):**

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- ... запросы ...
COMMIT;
```

---

**Вопрос:** Что такое WAL (Write-Ahead Logging)?
**Ответ:** WAL — это механизм, при котором все изменения сначала записываются в журнал (лог), прежде чем записываться в основное хранилище. Это обеспечивает надёжность и позволяет после сбоя восстановить базу из журнала. ([LabEx][1])
**Код:** WAL-конфигурация на уровне `postgresql.conf` — `wal_level`, `max_wal_size` и др.

---

## 2. Индексы и запросы

**Вопрос:** Когда и какие индексы использовать в PostgreSQL?
**Ответ:**

* B-tree — для большинства обычных операций `WHERE`, `JOIN`, `ORDER BY`.
* GIN / GiST — для `jsonb`, полнотекстового поиска, геоданных.
* Partial-индексы — когда часть строк имеет нужные значения (например `status = 'active'`).
  **Пример:**

```sql
CREATE INDEX idx_active_orders ON orders (user_id) WHERE status = 'active';
CREATE INDEX idx_meta_json ON orders USING GIN (meta jsonb_path_ops);
```

---

**Вопрос:** Что такое `EXPLAIN ANALYZE` и как его использовать для оптимизации запросов?
**Ответ:** `EXPLAIN ANALYZE` выводит план исполнения запроса и фактическую статистику выполнения (время, чтения и записи буферов). Это позволяет увидеть, где запрос “тормозит” (Seq Scan, Hash Join, nested loop и т.д.) и оптимизировать его. ([Habr][2])
**Пример:**

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM orders WHERE user_id = 123;
```

---

## 3. Поддержка и очистка данных

**Вопрос:** Что такое autovacuum и почему это важно?
**Ответ:** `autovacuum` — фоновая служба PostgreSQL, автоматически выполняющая `VACUUM` и `ANALYZE` для таблиц. Это критично для уменьшения “мертвых” строк (bloat) и обновления статистики, чтобы планировщик использовал актуальные данные. ([LabEx][1])

---

**Вопрос:** В чём разница между `VACUUM` и `VACUUM FULL`?
**Ответ:** `VACUUM` освобождает пространство мёртвых кортежей внутри файла, не блокируя таблицу, тогда как `VACUUM FULL` полностью переписывает таблицу, возвращает место ОС, но требует эксклюзивной блокировки. ([LabEx][1])

---

## 4. Расширения и масштабирование

**Вопрос:** Что такое `pg_stat_statements` и как его использовать для мониторинга производительности?
**Ответ:** `pg_stat_statements` — расширение, собирающее статистику по SQL-запросам (время, количество вызовов и т. д.). Используется для нахождения “тяжёлых” запросов и их оптимизации. ([bestcodes.ru][3])
**Пример:**

```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
SELECT query, calls, total_time, mean_time
  FROM pg_stat_statements
  ORDER BY total_time DESC
  LIMIT 10;
```

---

**Вопрос:** Когда имеет смысл использовать партиционирование (partitioning)?
**Ответ:** Партиционирование полезно, если таблица очень большая по размеру или объёму данных. Оно позволяет разбивать данные на логические сегменты (по дате, ID и т.д.), что ускоряет запросы (pruning партиций), улучшает обслуживание (удаление старых партиций) и индексирование. ([LabEx][1])
**Пример:**

```sql
CREATE TABLE orders (
  id BIGSERIAL,
  created_at TIMESTAMPTZ,
  ...
) PARTITION BY RANGE (created_at);

CREATE TABLE orders_2024 PARTITION OF orders FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

---

**Вопрос:** Объясните разницу между физической и логической репликацией.
**Ответ:**

* Физическая репликация копирует двоичные данные (блоки) — подходит для восстановления и “горячих” standby.
* Логическая репликация копирует изменения на уровне строк (DML) — можно реплицировать лишь часть таблиц, применять фильтры, реплицировать между разными версиями схем.

---

## 5. Транзакции и конкурентность

**Вопрос:** Как PostgreSQL реализует MVCC?
**Ответ:** Каждая транзакция работает со “снимком” данных. При обновлении строк не перезаписываются сразу — создаётся новая версия строки, а старая остаётся, пока другие транзакции её видят. Это обеспечивает изоляцию без жёстких блокировок. 

---

**Вопрос:** Как вы справляетесь со “table bloat” и почему он возникает?
**Ответ:** “Table bloat” — это раздувание таблицы из-за накопления мёртвых кортежей (MVCC). Решения: настроить `autovacuum`, запускать `VACUUM`, а если нужно — `VACUUM FULL` или использовать `pg_repack` для онлайн-реорганизации.

---

## 6. Репродакшн и резервное копирование

**Вопрос:** Как вы реализуете Point-in-Time Recovery (PITR) в PostgreSQL?
**Ответ:** Настроить архивацию WAL (Write-Ahead Log), делать базовые бэкапы (`pg_basebackup`), а при восстановлении — воспроизводить WAL файлы до нужной точки времени. Это позволяет откатиться к конкретной временной метке.

---

## Полезный SQL-код (пример вопросов + решение)

**Вопрос:** Напишите запрос, который выводит топ-5 пользователей по количеству заказов за последний месяц.

**Пример решения:**

```sql
SELECT user_id, COUNT(*) AS order_count
FROM orders
WHERE created_at >= NOW() - INTERVAL '1 month'
GROUP BY user_id
ORDER BY order_count DESC
LIMIT 5;
```

---